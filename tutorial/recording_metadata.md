# Recording Program Metadata

Here, you'll learn how to collect program metadata with the Adiak library.

## The Adiak library

Caliper works together with the [Adiak](https://github.com/LLNL/Adiak) library
to record program metadata. This data helps us with comparisons across runs - for
example, comparing performance between different machines or different program
configurations.

Adiak includes built-in functionality to record many common attributes:

```c
int adiak_user();  /* Makes a 'user' name/val with the real name of who's running the job */
int adiak_uid(); /* Makes a 'uid' name/val with the uid of who's running the job */
int adiak_launchdate(); /* Makes a 'launchdate' name/val with the date of when this job started */
int adiak_launchday(); /* Makes a 'launchday' name/val with date when this job started, but truncated to midnight */
int adiak_executable(); /* Makes an 'executable' name/val with the executable file for this job */
int adiak_executablepath(); /* Makes an 'executablepath' name/value with the full executable file path. */
int adiak_workdir(); /* Makes a 'working_directory' name/val with the cwd for this job */
int adiak_libraries(); /* Makes a 'libraries' name/value with the set of shared library paths. */
int adiak_cmdline(); /* Makes a 'cmdline' name/val string set with the command line parameters */
int adiak_hostname(); /* Makes a 'hostname' name/val with the hostname */
int adiak_clustername(); /* Makes a 'cluster' name/val with the cluster name (hostname with numbers stripped) */
int adiak_walltime(); /* Makes a 'walltime' name/val with the walltime how long this job ran */
int adiak_systime(); /* Makes a 'systime' name/val with the timeval of how much time was spent in IO */
int adiak_cputime(); /* Makes a 'cputime' name/val with the timeval of how much time was spent on the CPU */

int adiak_job_size(); /* Makes a 'jobsize' name/val with the number of ranks in an MPI job */
int adiak_hostlist(); /* Makes a 'hostlist' name/val with the set of hostnames in this MPI job */
int adiak_num_hosts(); /* Makes a 'numhosts' name/val with the number of hosts in this MPI job */
```

There is also a key-value style API to record program-specific information, like
program configuration settings:

```c
/**
 * adiak_namevalue registers a name/value pair.  The printf-style typestr describes the type of the
 * value, which is constructed from the string specifiers above.  The varargs contains parameters
 * for the type.  The entire type describes how value is encoded.  For example:
 *
 * adiak_namevalue("numrecords", adiak_general, "%d", 10);
 *
 * adiak_namevalue("buildcompiler", adiak_general, "%v", "gcc@4.7.3");
 *
 * double gridvalues[] = { 5.4, 18.1, 24.0, 92.8 };
 * adiak_namevalue("gridvals", adiak_general, "[%f]", gridvalues, 4);
 *
 * struct { int pos; const char *val; } letters[3] = { {1, 'a'}, {2, 'b'}, {3, 'c} }
 * adiak_namevalue("alphabet", adiak_general, "[(%u, %s)]", letters, 3, 2);
 **/
int adiak_namevalue(const char *name, int category, const char *subcategory, const char *typestr, ...);
```

A simpler form is available for C++:

```c++
adiak::value("key", value);
```

Caliper automatically adds the recorded metadata to the profiling output for
most output formats.

## Program metadata in LULESH

In our LULESH example, we record various system and execution attributes
(system name, number of MPI ranks, etc.), as well as program configuration
settings like problem size and number of iterations. This is done in the
`RecorGlobals` function in [lulesh-util.cc](../apps/LULESH/lulesh-util.cc):

```c++
// defined in lulesh-build-metadata.cc, which is generated by cmake
extern const char* buildMetadata[][2];

void RecordGlobals(const cmdLineOpts& opts, int num_threads)
{
    adiak::user();
    adiak::launchdate();
    adiak::executablepath();
    adiak::libraries();
    adiak::cmdline();
    adiak::clustername();
    adiak::jobsize();

    adiak::value("threads", num_threads);

    adiak::value("iterations", opts.its);
    adiak::value("problem_size", opts.nx);
    adiak::value("num_regions", opts.numReg);
    adiak::value("region_cost", opts.cost);
    adiak::value("region_balance", opts.balance);

    // add build metadata
    for (size_t i = 0; buildMetadata[i][0]; ++i)
       adiak::value(buildMetadata[i][0], buildMetadata[i][1]);
}
```

We also record build information like the compiler name, which is provided
by a CMake-generated source file
([lulesh-build-metadata.cc.in](../apps/LULESH/lulesh-build-metadata.cc):

```c++
const char* buildMetadata[][2] = {
  { "Compiler Name",    "@CMAKE_CXX_COMPILER_ID@" },
  { "Compiler Version", "@CMAKE_CXX_COMPILER_VERSION@" },
  { "Built by",         "@LULESH_BUILT_BY@" },
  { "Compiler Flags",   "@CMAKE_CXX_FLAGS@" },
  { 0, 0 }
};
```

At the end of the run, we record a global "figure-of-merit" as well as the
total elapsed time:

```c++
adiak::value("elapsed_time", elapsed_time);
adiak::value("figure_of_merit", 1000.0/grindTime2);
```

## Viewing program metadata

We can view the program metadata values in report outputs with the
`print.metadata` option:

```
$ CALI_CONFIG=runtime-report,print.metadata lulesh2.0 -i 10
cali.caliper.version : 2.7.0-dev
figure_of_merit      : 1257.281757
elapsed_time         :    0.214749
Compiler Flags       :
Built by             : boehme3
Compiler Version     : 11.0.0.11000033
Compiler Name        : AppleClang
region_balance       :           1
region_cost          :           1
num_regions          :          11
problem_size         :          30
iterations           :          10
threads              :           1
jobsize              :           1
cluster              : condor
user                 : boehme3
cali.channel         : runtime-report
Path                                       Time (E) Time (I) Time % (E) Time % (I)
main                                       0.004968 0.219693   2.226714  98.468910
  lulesh.cycle                             0.000042 0.214725   0.018825  96.242196
    LagrangeLeapFrog                       0.000031 0.214674   0.013895  96.219337
      CalcTimeConstraintsForElems          0.001336 0.001336   0.598810   0.598810
      LagrangeElements                     0.000190 0.096224   0.085160  43.128695
        ApplyMaterialPropertiesForElems    0.000797 0.048494   0.357224  21.735564
          EvalEOSForElems                  0.015742 0.047697   7.055744  21.378340
            CalcEnergyForElems             0.031955 0.031955  14.322596  14.322596
        CalcQForElems                      0.014044 0.020171   6.294681   9.040872
          CalcMonotonicQForElems           0.006127 0.006127   2.746191   2.746191
        CalcLagrangeElements               0.000838 0.027369   0.375601  12.267098
          CalcKinematicsForElems           0.026531 0.026531  11.891497  11.891497
      LagrangeNodal                        0.002712 0.117083   1.215549  52.477937
        CalcForceForNodes                  0.000355 0.114371   0.159115  51.262387
          CalcVolumeForceForElems          0.002560 0.114016   1.147421  51.103272
            CalcHourglassControlForElems   0.056492 0.090048  25.320359  40.360541
              CalcFBHourglassForceForElems 0.033556 0.033556  15.040182  15.040182
            IntegrateStressForElems        0.021408 0.021408   9.595310   9.595310
    TimeIncrement                          0.000009 0.000009   0.004034   0.004034
```

Most machine-readable formats produced by Caliper (JSON, .cali) also include
the metadata.